<ServerManagerConfiguration>
  <ProxyGroup name="sources">


<!--
===================================================================PV-BOV-->
    <SourceProxy name="PVImageReader" 
                 class="vtkPVImageReader"
                 label="PV Image Reader">
     <Documentation
       short_help="Read raw regular rectilinear grid data from a file." 
       long_help="Read raw regular rectilinear grid data from a file. The dimensions and type of the data must be specified.">
       The Image reader reads raw regular rectilinear grid (image/volume) data from a file. Because no metadata is provided, the user must specify information about the size, spacing, dimensionality, etc. about the dataset.
     </Documentation>
     <!-- Unlike most readers, we need to show the "filename" so that users
          can strip off the extension and replace it in the file pattern.
          I'm creating this "Property" hint that has an attribute to force
          whether the given property is shown in the GUI or not. -->
     <Hints>
       <Property name="FilePrefix" show="1"/>
     </Hints>

     <StringVectorProperty
        name="FilePrefix"
        command="SetFilePrefix"
        number_of_elements="1">
       <FileListDomain name="files"/>
       <Documentation>
         The text string contained in this property specifies the file prefix (directory plus common initial part of file name) for the raw binary uniform rectilinear grid dataset.
       </Documentation>
     </StringVectorProperty>

     <StringVectorProperty
        name="FilePattern"
        command="SetFilePattern"
        number_of_elements="1" 
        default_values="%s">
        <Documentation>
          The text string contained in the property specifies the format string to determine the file names necessary for reading this dataset. In creating the filenames, %s will be replaced by the prefix and %d by a digit which represents the slice number in Z. The format string is the same as that used by printf.
        </Documentation>
     </StringVectorProperty>

     <IntVectorProperty 
        name="DataScalarType" 
        command="SetDataScalarType" 
        number_of_elements="1"
        default_values="10" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="char"/>
         <Entry value="3" text="unsigned char"/>
         <Entry value="4" text="short"/>
         <Entry value="5" text="unsigned short"/>
         <Entry value="6" text="int"/>
         <Entry value="7" text="unsigned int"/>
         <Entry value="8" text="long"/>
         <Entry value="9" text="unsigned long"/>
         <Entry value="10" text="float"/>
         <Entry value="11" text="double"/>
       </EnumerationDomain>
       <Documentation>
         The value of this property indicates the scalar type of the pixels/voxels in the file(s): short, int, float ...
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="DataByteOrder" 
        command="SetDataByteOrder" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="BigEndian"/>
         <Entry value="1" text="LittleEndian"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates the byte order of the binary file(s).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="FileDimensionality"
        command="SetFileDimensionality"
        number_of_elements="1" 
        default_values="3">
       <EnumerationDomain name="enum">
         <Entry value="2" text="2"/>
         <Entry value="3" text="3"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates whether the file(s) in this dataset contain slices (2D) or volumes (3D).
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="DataOrigin"
         command="SetDataOrigin"
         number_of_elements="3"
         default_values="0.0 0.0 0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          The coordinate contained in this property specifies the position of the point with index (0,0,0).
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="DataSpacing"
         command="SetDataSpacing"
         number_of_elements="3"
         default_values="1.0 1.0 1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the size of a voxel in each dimension.
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="DataExtent"
        command="SetDataExtent"
        number_of_elements="6" 
        default_values="0 0 0 0 0 0" >
       <IntRangeDomain name="range"/>
       <Documentation>
         This property specifies the minimum and maximum index values of the data in each dimension (xmin, xmax, ymin, ymax, zmin, zmax).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="NumberOfScalarComponents"
        command="SetNumberOfScalarComponents"
        number_of_elements="1" 
        default_values="1" >
       <IntRangeDomain name="range"/>
       <Documentation>
         This property specifies the number of componenets the scalar value at each pixel or voxel has (e.g., RGB - 3 scalar components).
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty
        name="ScalarArrayName"
        command="SetScalarArrayName"
        number_of_elements="1" 
        default_values="ImageFile">
        <Documentation>
          This property contains a text string listing a name to assign to the point-centered data array read.
        </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="FileLowerLeft"
                        command="SetFileLowerLeft"
                        number_of_elements="1"
                        default_values="1">
       <BooleanDomain name="bool" />
       <Documentation>
         This property determines whether the data originates in the lower left corner (on) or the upper left corner (off).  Most scientific data is written with a right-handed axes that originates in the lower left corner.  However, several 2D image file formats write the image from the upper left corner.
       </Documentation>
     </IntVectorProperty>
   <!-- End ImageReader -->
   </SourceProxy>

<!--
========================================================================U.I. -->
<Proxy name="BOVReaderUI">
  <Documentation
      short_help="BOV reader.">
      long_help="BOV Reader. Reads raw or brick of values files in parallel handles time."
  </Documentation>
  <!-- File Name -->
  <StringVectorProperty
    name="FileName"
    animateable="0"
    command="SetFileName"
    number_of_elements="1">
  <FileListDomain name="files"/>
  <Documentation>
    This property specifies the file name for the reader.
  </Documentation>
  </StringVectorProperty>
  <!-- Time Steps -->
  <DoubleVectorProperty 
    name="TimestepValues"
    information_only="1">
    <TimeStepsInformationHelper/>
    <Documentation>
    Available timestep values.
    </Documentation>
  </DoubleVectorProperty>
  <!-- Array selection -->
  <StringVectorProperty
    name="PointArrayInfo"
    information_only="1">
    <ArraySelectionInformationHelper attribute_name="Point"/>
  </StringVectorProperty>
  <StringVectorProperty
    name="PointArrayStatus"
    command="SetPointArrayStatus"
    number_of_elements="0"
    repeat_command="1"
    number_of_elements_per_command="2"
    element_types="2 0"
    information_property="PointArrayInfo"
    label="Arrays">
    <ArraySelectionDomain name="array_list">
      <RequiredProperties>
        <Property name="PointArrayInfo" function="ArrayList"/>
      </RequiredProperties>
    </ArraySelectionDomain>
    <Documentation>
    This property is used to select arrays to read in.
  </Documentation>
  </StringVectorProperty>
  <!-- Subset selection -->
  <IntVectorProperty 
    name="ISubsetInfo"
    command="GetISubsetRange"
    information_only="1">
    <SimpleIntInformationHelper/>
  </IntVectorProperty>
  <IntVectorProperty 
    name="ISubset"
    command="SetISubset"
    number_of_elements="2" 
    default_values="1 0"
    animateable="0"
    information_property="ISubsetInfo" >
    <IntRangeDomain name="range">
      <RequiredProperties>
          <Property name="ISubsetInfo" function="Range"/>
      </RequiredProperties>
    </IntRangeDomain>
    <Documentation>
      This property controls what subset of data is read in. Subset for smaller memory footprint and better interactivity.
    </Documentation>
  </IntVectorProperty>
  <IntVectorProperty 
    name="JSubsetInfo"
    command="GetJSubsetRange"
    information_only="1">
    <SimpleIntInformationHelper/>
  </IntVectorProperty>
  <IntVectorProperty 
    name="JSubset"
    command="SetJSubset"
    number_of_elements="2" 
    default_values="1 0"
    animateable="0"
    information_property="JSubsetInfo" >
    <IntRangeDomain name="range">
      <RequiredProperties>
          <Property name="JSubsetInfo" function="Range"/>
      </RequiredProperties>
    </IntRangeDomain>
    <Documentation>
      This property controls what subset of data is read in. Subset for smaller memory footprint and better interactivity.
    </Documentation>
  </IntVectorProperty>
  <IntVectorProperty 
    name="KSubsetInfo"
    command="GetKSubsetRange"
    information_only="1">
    <SimpleIntInformationHelper/>
  </IntVectorProperty>
  <IntVectorProperty 
    name="KSubset"
    command="SetKSubset"
    number_of_elements="2" 
    default_values="1 0"
    animateable="0"
    information_property="KSubsetInfo" >
    <IntRangeDomain name="range">
      <RequiredProperties>
          <Property name="KSubsetInfo" function="Range"/>
      </RequiredProperties>
    </IntRangeDomain>
    <Documentation>
      This property controls what subset of data is read in. Subset for smaller memory footprint and better interactivity.
    </Documentation>
  </IntVectorProperty>
</Proxy>

<!--
========================================================================BOV Reader -->
<SourceProxy
    name="BOVReader"
    class="vtkBOVReader"
    label="BOV Reader"
    base_proxyname="BOVReaderUI"
    base_proxygroup="sources">
  <Documentation
      short_help="BOV reader.">
      long_help="BOV Reader. Reads raw or brick of values files in parallel handles time."
  </Documentation>
  <!-- Meta Flag -->
  <IntVectorProperty 
    name="MetaRead" 
    command="SetMetaRead" 
    number_of_elements="1"
    default_values="0">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked meta mode is active. Meta data will be read and processed however actual read will be 
    deffered to down stream filters. If unchecked the reader performs as expected, an actual read of
    the requested arrays.
    </Documentation>
  </IntVectorProperty>
  <Hints>
    <Property name="MetaRead" show="0"/>
  </Hints>
</SourceProxy>

<!--
========================================================================BOV Meta Reader -->
<SourceProxy
    name="BOVMetaReader"
    class="vtkBOVReader"
    label="BOV Meta Reader"
    base_proxyname="BOVReaderUI"
    base_proxygroup="sources">
  <Documentation
      short_help="BOV reader.">
      long_help="BOV Reader. Reads raw or brick of values files in parallel handles time."
  </Documentation>
  <!-- Meta Flag -->
  <IntVectorProperty 
    name="MetaRead" 
    command="SetMetaRead" 
    number_of_elements="1"
    default_values="1">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked meta mode is active. Meta data will be read and processed however actual read will be 
    deffered to down stream filters. If unchecked the reader performs as expected, an actual read of
    the requested arrays.
    </Documentation>
  </IntVectorProperty>
  <Hints>
    <Property name="MetaRead" show="0"/>
  </Hints>
</SourceProxy>

</ProxyGroup>

<ProxyGroup name="filters">
<!--==================================================================== -->
  <SourceProxy 
    name="vtkFieldTopologyAnalyzer" 
    class="vtkFieldTopologyAnalyzer"
    label="Field Topology Analyzer">
    <Documentation
      long_help="Long Documentation"
      short_help="Short Documentation">
      Textual Documentation.
    </Documentation>

    <!-- Out -->
    <OutputPort name="Seed Points" index="0" />
    <OutputPort name="Field Lines (+)" index="1" />
    <OutputPort name="Field Lines (-)" index="2" />
    <OutputPort name="Surface Intersect" index="3" />
    <!-- In -->
    <!-- clean_command="ResetDatasetInputConnections" -->
    <InputProperty
      name="Input"
      command="AddDatasetInputConnection"
      clean_command="ClearDatasetInputConnections"
      multiple_input="0">
      <ProxyGroupDomain name="groups">
        <Group name="sources"/>
        <Group name="filters"/>
      </ProxyGroupDomain>
      <DataTypeDomain name="input_type">
        <DataType value="vtkDataSet"/>
      </DataTypeDomain>
      <InputArrayDomain name="input_array"
        attribute_type="point"
        number_of_components="3"/>
        <Documentation>
          Used to set a dataset with vector field to analyze.
        </Documentation>
      </InputProperty>
      <!--lean_command="ResetBoundaryInputConnections"-->
      <InputProperty
        name="Source"
        command="AddBoundaryInputConnection"
        clean_command="ClearBoundaryInputConnections"
        multiple_input="1">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <Documentation>
          This input should contian boundary surfaces.
        </Documentation>
     </InputProperty>
      <!-- Vector Field -->
     <StringVectorProperty 
      name="SelectInputVectors" 
      command="SetInputArrayToProcess"
      number_of_elements="5"
      element_types="0 0 0 0 2"
      animateable="0"
      label="Vectors">
      <ArrayListDomain name="array_list" attribute_type="Vectors">
        <RequiredProperties>
          <Property name="Input" function="Input"/>
        </RequiredProperties>
      </ArrayListDomain>
      <Documentation>
        This property contains the name of the vector array from which to generate streamlines.
     </Documentation>
     </StringVectorProperty>
     <!-- Integration length -->
     <DoubleVectorProperty
       name="StepSize"
       label="Step Size"
       command="SetStepSize" 
       number_of_elements="1"
       default_values="0.001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the step size takein during field line integration.
       </Documentation>
     </DoubleVectorProperty>
     <!-- Bounds on stream line generation -->
     <IntVectorProperty 
       name="MaxNumberOfSteps" 
       label="Max Steps"
       command="SetMaxNumberOfSteps" 
       number_of_elements="1"
       default_values="10000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum number of steps, beyond which streamline integration is terminated.
       </Documentation>
     </IntVectorProperty>
     <!-- Bounds on stream line generation -->
     <DoubleVectorProperty
       name="MaxLineLength"
       label="Max Line Length"
       command="SetMaxLineLength"
       number_of_elements="1"
       default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="10.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         This property specifies the maximum streamline length (i.e., physical arc length), beyond which line integration is terminated.
       </Documentation>
     </DoubleVectorProperty>
    <!-- Cut functuion -->
    <ProxyProperty 
      name="CutFunction"
      command="SetCutFunction"
      label="Slice Type">
          <ProxyGroupDomain name="groups">
            <Group name="implicit_functions"/>
          </ProxyGroupDomain>
          <ProxyListDomain name="proxy_list">
            <Proxy group="implicit_functions" name="Plane" />
            <!--
            <Proxy group="implicit_functions" name="Box" />
            <Proxy group="implicit_functions" name="Sphere" />
            -->
          </ProxyListDomain>
          <Documentation>
            This property sets the type of intersecting geometry, and associated parameters.
          </Documentation>
    </ProxyProperty>
    <IntVectorProperty 
      name="Resolution"
      command="SetCutResolution"
      number_of_elements="1" 
      default_values="1"
      animateable="0">
      <Documentation>
        This property controls the resolution of the seed object.
      </Documentation>
    </IntVectorProperty>
    <!-- ParaView tweaks -->
    <Hints>
      <Visibility replace_input="0" />
    </Hints>
  <!-- End vtkFieldTopologyAnalyzer -->
  </SourceProxy>
 
 <!-- ==================================================================== -->
 <SourceProxy name="vtkDistributedFieldTracer" class="vtkDistributedFieldTracer"
    label="Field Tracer">
    <Documentation
       long_help="Integrate field lines in a vector field."
       short_help="Integrate field lines in a vector field.">
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. Production of streamlines terminates if a streamline crosses the exterior boundary of the input dataset. Other reasons for termination are listed for the MaximumNumberOfSteps, TerminalSpeed, and MaximumPropagation properties. This filter operates on any type of dataset, provided it has point-centered vectors. The output is polygonal data containing polylines. 
    </Documentation>
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="1">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            This property specifies the input to the Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Seed Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <Documentation>
             The value of this property determines how the seeds for the 
             streamlines will be generated.
           </Documentation>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <!-- Never generate any seeds, user must supply -->
     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="0"/>
     <!-- Always integrate in both directions -->
     <IntVectorProperty 
       name="IntegrationDirection" 
       command="SetIntegrationDirection" 
       number_of_elements="1"
       default_values="2"/>
     <!-- Always use the best integrator -->
     <IntVectorProperty 
       name="IntegratorType" 
       command="SetIntegratorType" 
       number_of_elements="1"
       default_values="2"/>
     <!-- Always measure integrate as multiple of cell length -->
     <IntVectorProperty 
       name="IntegrationStepUnit"
       label="Integration Step Unit"
       command="SetIntegrationStepUnit" 
       number_of_elements="1"
       default_values="2"/>

     <DoubleVectorProperty
       name="InitialIntegrationStep"
       label="Initial Step Length"
       command="SetInitialIntegrationStep"
       number_of_elements="1"
       default_values="0.2" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the initial integration step size as a multiple of cell lengths.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MinimumIntegrationStep"
       label="Minimum Step Length"
       command="SetMinimumIntegrationStep"
       number_of_elements="1"
       default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the minimum integration step size.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MaximumIntegrationStep"
       label="Maximum Step Length"
       command="SetMaximumIntegrationStep"
       number_of_elements="1"
       default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum integration step size.
       </Documentation>
     </DoubleVectorProperty>  

     <IntVectorProperty 
       name="MaximumNumberOfSteps" 
       label="Maximum Steps"
       command="SetMaximumNumberOfSteps" 
       number_of_elements="1"
       default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum number of steps, beyond which streamline integration is terminated.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="MaximumPropagation"
       label="Maximum Streamline Length"
       command="SetMaximumPropagation"
       number_of_elements="1"
       default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="10.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         This property specifies the maximum streamline length (i.e., physical arc length), beyond which line integration is terminated.
       </Documentation>       
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="TerminalSpeed"
       label="Terminal Speed"
       command="SetTerminalSpeed"
       number_of_elements="1"
       default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the terminal speed, below which particle advection/integration is terminated.
       </Documentation>
     </DoubleVectorProperty>
     
     <!-- Always use this error -->
     <DoubleVectorProperty
       name="MaximumError"
       command="SetMaximumError"
       number_of_elements="1"
       default_values="0.000001"
       information_only="1"/>
     <Hints>
       <Visibility replace_input="2" />
       <Property name="NumberOfPoints" show="0"/>
       <Property name="IntegrationDirection" show="0"/>
       <Property name="IntegratorType" show="0"/>
       <Property name="IntegrationStepUnit" show="0"/>
       <Property name="MaximumError" show="0"/>
     </Hints>
   <!-- End StreamTracer -->
   </SourceProxy>


<!-- ==================================================================== -->
  <Proxy name="vtkOOCFieldTracerUI">
    <Documentation
       long_help="Trace field lines in a vector field."
       short_help="Trace field lines in a vector field.">
      Trace field lines in a vector field.
    </Documentation>
    <!-- Dataset input -->
    <InputProperty
       name="DatasetInput"
       command="AddVectorInputConnection"
       clean_command="ClearVectorInputConnections"
       label="Vector Field">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="0">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point" number_of_components="3"/>
          <Documentation>
            Dataset containing the vector field.
          </Documentation>
     </InputProperty>
     <!-- Seed input -->
     <InputProperty
        name="SeedPointInput"
        command="AddSeedPointInputConnection"
        clean_command="ClearSeedPointInputConnections"
        label="Seed Cells"
        multiple_input="0">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <Documentation>
             Cells to generate seed points from (at cell center).
           </Documentation>
      </InputProperty>
     <!-- Terminator Surface input -->
     <InputProperty
        name="TerminatorInput"
        command="AddTerminatorInputConnection"
        clean_command="ClearTerminatorInputConnections"
        label="Terminator Surfaces"
        multiple_input="1"
        optional="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <Documentation>
             Surfaces which if present stop field line integration when a field line crosses one.
           </Documentation>
      </InputProperty>

     <!-- Vector Field Selection -->
     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="DatasetInput" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <!-- OOC Reader parameter -->
     <IntVectorProperty 
       name="OOCNeighborhoodSize" 
       label="OOC Read Size"
       command="SetOOCNeighborhoodSize"
       number_of_elements="1"
       default_values="0" >
       <IntRangeDomain name="range" min="-1"/>
       <Documentation>
         Control the size of the OOC reads (context dependent meaning).
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="InitialStep"
       label="Initial Step"
       command="SetInitialStep"
       number_of_elements="1"
       default_values="0.1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Initial integration step size as a multiple of cell lengths.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MinStep"
       label="Minimum Step"
       command="SetMinStep"
       number_of_elements="1"
       default_values="0.1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Minimum integration step size as a multiple of cell lengths.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MaxStep"
       label="Maximum Step"
       command="SetMaxStep"
       number_of_elements="1"
       default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Maximum integration step size as a multiple of cell lengths.
       </Documentation>
     </DoubleVectorProperty>  

     <IntVectorProperty 
       name="MaxNumberOfSteps"
       label="Maximum Steps"
       command="SetMaxNumberOfSteps" 
       number_of_elements="1"
       default_values="1000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         Maximum number of steps, beyond which integration is terminated.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="MaxLineLength"
       label="Maximum Length"
       command="SetMaxLineLength"
       number_of_elements="1"
       default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="10.0">
         <RequiredProperties>
            <Property name="DatasetInput" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         Maximum streamline arc length beyond which line integration is terminated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="NullThreshold"
       label="Null Threshold"
       command="SetNullThreshold"
       number_of_elements="1"
       default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the terminal speed, below which particle advection/integration is terminated.
       </Documentation>
     </DoubleVectorProperty>

      <!-- Colormap/Legened control -->
     <IntVectorProperty 
        name="Squeeze Color Map" 
        command="SetSqueezeColorMap" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
        Set the color map to simple where termination due to out of bounds,stagnation, and short integration map to the same case.
       </Documentation>
     </IntVectorProperty>

     <!-- Always use this error -->
     <DoubleVectorProperty
       name="MaxError"
       command="SetMaxError"
       number_of_elements="1"
       default_values="0.000001"/>
     <!-- Always measure integrate as multiple of cell length -->
     <IntVectorProperty 
       name="StepUnit"
       label="Step Unit"
       command="SetStepUnit" 
       number_of_elements="1"
       default_values="2"/>
     <!-- Hide some of these -->
     <Hints>
       <Visibility replace_input="2" />
       <Property name="StepUnit" show="0"/>
       <Property name="MaxError" show="0"/>
     </Hints>
   <!-- End FieldTracerUI -->
   </Proxy>

<!-- ==================================================================== -->
<SourceProxy name="vtkOOCFieldTracer" 
    class="vtkOOCFieldTracer"
    label="OOC Field Tracer"
    base_proxyname="vtkOOCFieldTracerUI"
    base_proxygroup="filters">

  <!-- Out -->
  <OutputPort name="Field Lines" index="0" />
  <!-- Meta Flag -->
  <IntVectorProperty 
    name="TopologyMode" 
    command="SetTopologyMode" 
    number_of_elements="1"
    default_values="0">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked topology mode is active and the filter produces a topology
    map rather than field lines.
    </Documentation>
  </IntVectorProperty>
  <Hints>
    <Property name="TopologyMode" show="0"/>
    <Property name="StepUnit" show="0"/>
    <Property name="MaxError" show="0"/>
  </Hints>
   <!-- End OOCFieldTracer -->
</SourceProxy>

<!-- ==================================================================== -->
<SourceProxy name="vtkOOCFieldTopologyMapper" 
    class="vtkOOCFieldTracer"
    label="OOC Field Topology Mapper"
    base_proxyname="vtkOOCFieldTracerUI"
    base_proxygroup="filters">

  <!-- Out -->
  <OutputPort name="Topology Map" index="0" />
  <!-- Meta Flag -->
  <IntVectorProperty 
    name="TopologyMode" 
    command="SetTopologyMode" 
    number_of_elements="1"
    default_values="1">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked topology mode is active and the filter produces a topology
    map rather than field lines.
    </Documentation>
  </IntVectorProperty>

  <Hints>
    <Property name="TopologyMode" show="0"/>
    <Property name="StepUnit" show="0"/>
    <Property name="MaxError" show="0"/>
  </Hints>
   <!-- End FieldTracer -->
</SourceProxy>







<!-- ==================================================================== -->
<SourceProxy name="vtkOOCDFieldTracer" 
    class="vtkOOCDFieldTracer"
    label="OOCD Field Tracer"
    base_proxyname="vtkOOCFieldTracerUI"
    base_proxygroup="filters">

  <!-- Out -->
  <OutputPort name="Field Lines" index="0" />

  <!-- Topo Flag -->
  <IntVectorProperty 
    name="TopologyMode" 
    command="SetTopologyMode" 
    number_of_elements="1"
    default_values="0">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked topology mode is active and the filter produces a topology
    map rather than field lines.
    </Documentation>
  </IntVectorProperty>
  
  <!-- Load balancing/work scheduling control -->
  <IntVectorProperty 
    name="Use Dynamic Scheduler"
    command="SetUseDynamicScheduler"
    number_of_elements="1"
    default_values="0" > 
    <BooleanDomain name="bool"/>
    <Documentation>
    When set the work is by a simple self-scheduling algorithm. In this case all of the seed source data has to be duplicated 
    on all processes. This must be off if this is not the case.
    </Documentation>
  </IntVectorProperty>

  <!-- Load balancing controls -->
  <IntVectorProperty 
    name="MasterBlockSize"
    command="SetMasterBlockSize"
    number_of_elements="1"
    default_values="16"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work the master does in between servicing work requests
      from the workers. Should be much smaller the WorkerBlockSize.
    </Documentation>
  </IntVectorProperty>
    <IntVectorProperty 
    name="WorkerBlockSize"
    command="SetWorkerBlockSize"
    number_of_elements="1"
    default_values="512"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work is given to the worker processes at each
      request.
    </Documentation>
  </IntVectorProperty>

  <Hints>
    <Property name="TopologyMode" show="0"/>
    <Property name="StepUnit" show="0"/>
    <Property name="MaxError" show="0"/>
  </Hints>
   <!-- End OOCFieldTracer -->
</SourceProxy>

<!-- ==================================================================== -->
<SourceProxy name="vtkOOCDFieldTopologyMapper" 
    class="vtkOOCDFieldTracer"
    label="OOCD Field Topology Mapper"
    base_proxyname="vtkOOCFieldTracerUI"
    base_proxygroup="filters">

  <!-- Out -->
  <OutputPort name="Topology Map" index="0" />

  <!-- Topo Flag -->
  <IntVectorProperty 
    name="TopologyMode" 
    command="SetTopologyMode" 
    number_of_elements="1"
    default_values="1">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked topology mode is active and the filter produces a topology
    map rather than field lines.
    </Documentation>
  </IntVectorProperty>

  <!-- Load balancing/work scheduling control -->
  <IntVectorProperty 
    name="Use Dynamic Scheduler"
    command="SetUseDynamicScheduler"
    number_of_elements="1"
    default_values="1" > 
    <BooleanDomain name="bool"/>
    <Documentation>
    When set the work is by a simple self-scheduling algorithm. In this case all of the seed source data has to be duplicated 
    on all processes. This must be off if this is not the case.
    </Documentation>
  </IntVectorProperty>

  <!-- Load balancing controls -->
  <IntVectorProperty 
    name="MasterBlockSize"
    command="SetMasterBlockSize"
    number_of_elements="1"
    default_values="16"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work the master does in between servicing work requests
      from the workers. Should be much smaller the WorkerBlockSize.
    </Documentation>
  </IntVectorProperty>
    <IntVectorProperty 
    name="WorkerBlockSize"
    command="SetWorkerBlockSize"
    number_of_elements="1"
    default_values="512"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work is given to the worker processes at each
      request.
    </Documentation>
  </IntVectorProperty>

  <Hints>
    <Property name="TopologyMode" show="0"/>
    <Property name="StepUnit" show="0"/>
    <Property name="MaxError" show="0"/>
  </Hints>
   <!-- End FieldTracer -->
</SourceProxy>





















<!-- ==================================================================== -->
  <SourceProxy 
    name="vtkFieldAnalysis" 
    class="vtkFieldAnalysis"
    label="Field Analysis">
    <Documentation
      long_help="Long Documentation"
      short_help="Short Documentation">
      Textual Documentation.
    </Documentation>

     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             This property specifies the input to the Warp (vector) filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         label="Vectors">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              The value of this property contains the name of the vector array by which to warp the dataset's point coordinates.
            </Documentation>
      </StringVectorProperty> 

      <IntVectorProperty
        name="ComputeFaceDivergence"
        label="Face-Centered Divergence"
        command="SetComputeFaceDivergence"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Compute divergence using a face centered stencil (Data on CT/Yee cells).
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeCurrentHelicity"
        label="Current-Helicity"
        command="SetComputeCurrentHelicity"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Compute the current/velocity helicity of the vector field using a point centered stencil.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeRotation"
        label="Rotation"
        command="SetComputeRotation"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Compute the rotation of the vector field using a point centered stencil.
        </Documentation>
     </IntVectorProperty>
  <!-- End vtkFieldAnalysis -->
  </SourceProxy>









</ProxyGroup>
<ProxyGroup name="sources">

  <!-- ==================================================================== -->
  <SourceProxy name="vtkSQPlaneSource" class="vtkSQPlaneSource" label="SQ Plane">
      <Documentation
        long_help="Create a parallelogram given an origin and two points. The resolution indicates the number of division along each axis of the plane." 
        short_help="Create a parallelogram from an origin and two points">
        The Plane source can be used to add a polygonal parallelogram to the 3D scene.
      </Documentation>

      <StringVectorProperty
         name="Name"
         command="SetDescriptiveName"
         number_of_elements="1">
        <Documentation>
          Give the object a name that may be used downstream to identify it.
        </Documentation>
      </StringVectorProperty>
     <!--<StringVectorProperty name="GetName"
        command="GetDescriptiveName"
        information_only="1" >
        <SimpleStringInformationHelper />
     </StringVectorProperty>-->

      <DoubleVectorProperty
         name="Origin"
         command="SetOrigin"
         number_of_elements="3"
         animateable="1"
         default_values="0.0 0.0 0.0">
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the 3D coordinate of the origin (one corner) of the plane.
        </Documentation>
      </DoubleVectorProperty>
      <!--
      information_property="OriginInfo"
      <DoubleVectorProperty name="OriginInfo"
        command="GetOrigin"
        information_only="1"
        number_of_elements="3"
        default_values="0.0 0.0 0.0">
        <SimpleDoubleInformationHelper />
     </DoubleVectorProperty>-->

      <DoubleVectorProperty
         name="Point1"
         command="SetPoint1"
         number_of_elements="3"
         animateable="1"
         default_values="1.0 0.0 0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the 3D coordinate a second corner of the parallelogram.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="Point2"
         command="SetPoint2"
         number_of_elements="3"
         animateable="1"
         default_values="0.0 1.0 0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the 3D coordinate a third corner of the parallelogram.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="XResolution"
         command="SetXResolution"
         number_of_elements="1"
         default_values="1" >
        <IntRangeDomain name="range" min="1" />
        <Documentation>
          This property specifies the number of divisions along the X axis of the parallelogram.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="YResolution"
         command="SetYResolution"
         number_of_elements="1"
         default_values="1" >
        <IntRangeDomain name="range" min="1" />
        <Documentation>
          This property specifies the number of divisions along the Y axis of the parallelogram.
        </Documentation>
      </IntVectorProperty>
   <!-- End Plane -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="vtkSQSphereSource" class="vtkSQSphereSource" label="Sphere">
      <Documentation
        long_help="Create a 3D sphere given a center and radius." 
        short_help="Create a 3D sphere">
          The Sphere source can be used to add a polygonal sphere to the 3D scene. The output of the Sphere source is polygonal data with point normals defined.
      </Documentation>

      <StringVectorProperty
         name="Name"
         command="SetDescriptiveName"
         number_of_elements="1">
        <Documentation>
          Give the object a name that may be used downstream to identify it.
        </Documentation>
      </StringVectorProperty>
      
      <DoubleVectorProperty
         name="Center"
         command="SetCenter"
         number_of_elements="3"
         animateable="1"
         default_values="0.0 0.0 0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the 3D coordinates for the center of the sphere.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="Radius"
         command="SetRadius"
         number_of_elements="1"
         animateable="1"
         default_values="0.5" >
        <DoubleRangeDomain name="range" min="0"/>
        <Documentation>
          This property specifies the radius of the sphere.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="ThetaResolution"
         command="SetThetaResolution"
         number_of_elements="1"
         default_values="8" >
        <IntRangeDomain name="range" min="3" max="1024" />
        <Documentation>
          The value of this property represents the number of divisions between Start Theta and End Theta around the sphere. (See the Start Theta and End Theta properties.) The theta divisions are similar to longitude lines on the earth. The higher the resolution, the closer the approximation will come to a sphere, and the more polygons there will be.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="StartTheta"
         command="SetStartTheta"
         number_of_elements="1"
         animateable="1"
         default_values="0" >
        <DoubleRangeDomain name="range" min="0" max="360" />
        <Documentation>
          To form a complete sphere, the value of this property should be 0 degrees, and the value of the End Theta property should be 360 degrees. The value of this property can be adjusted to form only a portion of a sphere.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="EndTheta"
         command="SetEndTheta"
         number_of_elements="1"
         animateable="1"
         default_values="360" >
        <DoubleRangeDomain name="range" min="0" max="360" />
        <Documentation>
          The value of this property can be adjusted to form only a portion of a sphere. This value is measured in degrees.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="PhiResolution"
         command="SetPhiResolution"
         number_of_elements="1"
         default_values="8" >
        <IntRangeDomain name="range" min="3" max="1024" />
        <Documentation>
          The value of this property represents the number of divisions between Start Phi and End Phi on the sphere. (See the Start Phi and End Phi properties.) The phi divisions are similar to latitude lines on the earth.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="StartPhi"
         command="SetStartPhi"
         number_of_elements="1"
         animateable="1"
         default_values="0" >
        <DoubleRangeDomain name="range" min="0" max="180" />
        <Documentation>
          To form a complete sphere, the value of this property should be 0 degrees, and the value of the End Phi property should be 180 degrees. The value of this property can be adjusted to form only a portion of a sphere.
          Set the starting angle (in degrees) in the latitudinal direction.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="EndPhi"
         command="SetEndPhi"
         number_of_elements="1"
         animateable="1"
         default_values="180" >
        <DoubleRangeDomain name="range" min="0" max="180" />
        <Documentation>
          The value of this property can be adjusted to form only a portion of a sphere. The value is measured in degrees.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End Sphere -->
   </SourceProxy>
   
    <!-- ==================================================================== -->
  <SourceProxy name="vtkProcessMonitor" class="vtkProcessMonitor" label="Process Monitor">
      <Documentation
        long_help="A custom Qt panel that manages and monitors the running processes."
        short_help="A custom Qt panel that manages and monitors the running processes.">
        A custom panel that manages and monitors the running processes.
      </Documentation>

     <StringVectorProperty name="ConfigStream"
        command="GetConfigStream"
        information_only="1" >
        <SimpleStringInformationHelper />
     </StringVectorProperty>

   <!-- End Debug Panel -->
   </SourceProxy>

</ProxyGroup>
 
</ServerManagerConfiguration>
