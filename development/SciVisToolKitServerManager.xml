<!--
   ____    _ __           ____               __    ____
  / __/___(_) /  ___ ____/ __ \__ _____ ___ / /_  /  _/__  ____
 _\ \/ __/ / _ \/ -_) __/ /_/ / // / -_|_-</ __/ _/ // _ \/ __/
/___/\__/_/_.__/\__/_/  \___\_\_,_/\__/___/\__/ /___/_//_/\__(_) 

Copyright 2008 SciberQuest Inc.
-->

<ServerManagerConfiguration>

<!--
*******************************************************************************
*                                                                             *
*                                   Readers                                   *
*                                                                             *
*******************************************************************************
-->
<ProxyGroup name="common-ui">
<!--========================================================================-->
<Proxy name="BOVReaderUI">
  <Documentation
      short_help="BOV reader.">
      long_help="BOV Reader. Reads raw or brick of values files in parallel handles time."
  </Documentation>
  <!-- File Name -->
  <StringVectorProperty
    name="FileName"
    animateable="0"
    command="SetFileName"
    number_of_elements="1">
  <FileListDomain name="files"/>
  <Documentation>
    This property specifies the file name for the reader.
  </Documentation>
  </StringVectorProperty>
  <!-- Time Steps -->
  <DoubleVectorProperty 
    name="TimestepValues"
    information_only="1">
    <TimeStepsInformationHelper/>
    <Documentation>
    Available timestep values.
    </Documentation>
  </DoubleVectorProperty>
  <!-- Array selection -->
  <StringVectorProperty
    name="PointArrayInfo"
    information_only="1">
    <ArraySelectionInformationHelper attribute_name="Point"/>
  </StringVectorProperty>
  <StringVectorProperty
    name="PointArrayStatus"
    command="SetPointArrayStatus"
    number_of_elements="0"
    repeat_command="1"
    number_of_elements_per_command="2"
    element_types="2 0"
    information_property="PointArrayInfo"
    label="Arrays">
    <ArraySelectionDomain name="array_list">
      <RequiredProperties>
        <Property name="PointArrayInfo" function="ArrayList"/>
      </RequiredProperties>
    </ArraySelectionDomain>
    <Documentation>
    This property is used to select arrays to read in.
  </Documentation>
  </StringVectorProperty>
  <!-- Subset selection -->
  <IntVectorProperty 
    name="ISubsetInfo"
    command="GetISubsetRange"
    information_only="1">
    <SimpleIntInformationHelper/>
  </IntVectorProperty>
  <IntVectorProperty 
    name="ISubset"
    command="SetISubset"
    number_of_elements="2" 
    default_values="1 0"
    animateable="0"
    information_property="ISubsetInfo" >
    <IntRangeDomain name="range">
      <RequiredProperties>
          <Property name="ISubsetInfo" function="Range"/>
      </RequiredProperties>
    </IntRangeDomain>
    <Documentation>
      This property controls what subset of data is read in. Subset for smaller memory footprint and better interactivity.
    </Documentation>
  </IntVectorProperty>
  <IntVectorProperty 
    name="JSubsetInfo"
    command="GetJSubsetRange"
    information_only="1">
    <SimpleIntInformationHelper/>
  </IntVectorProperty>
  <IntVectorProperty 
    name="JSubset"
    command="SetJSubset"
    number_of_elements="2" 
    default_values="1 0"
    animateable="0"
    information_property="JSubsetInfo" >
    <IntRangeDomain name="range">
      <RequiredProperties>
          <Property name="JSubsetInfo" function="Range"/>
      </RequiredProperties>
    </IntRangeDomain>
    <Documentation>
      This property controls what subset of data is read in. Subset for smaller memory footprint and better interactivity.
    </Documentation>
  </IntVectorProperty>
  <IntVectorProperty 
    name="KSubsetInfo"
    command="GetKSubsetRange"
    information_only="1">
    <SimpleIntInformationHelper/>
  </IntVectorProperty>
  <IntVectorProperty 
    name="KSubset"
    command="SetKSubset"
    number_of_elements="2" 
    default_values="1 0"
    animateable="0"
    information_property="KSubsetInfo" >
    <IntRangeDomain name="range">
      <RequiredProperties>
          <Property name="KSubsetInfo" function="Range"/>
      </RequiredProperties>
    </IntRangeDomain>
    <Documentation>
      This property controls what subset of data is read in. Subset for smaller memory footprint and better interactivity.
    </Documentation>
  </IntVectorProperty>
</Proxy>

</ProxyGroup>

<ProxyGroup name="sources">

<!--========================================================================-->
<SourceProxy
    name="BOVReader"
    class="vtkBOVReader"
    label="BOV Reader"
    base_proxyname="BOVReaderUI"
    base_proxygroup="common-ui">
  <Documentation
      short_help="BOV reader.">
      long_help="BOV Reader. Reads raw or brick of values files in parallel handles time."
  </Documentation>
  <!-- Meta Flag -->
  <IntVectorProperty 
    name="MetaRead" 
    command="SetMetaRead" 
    number_of_elements="1"
    default_values="0">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked meta mode is active. Meta data will be read and processed however actual read will be 
    deffered to down stream filters. If unchecked the reader performs as expected, an actual read of
    the requested arrays.
    </Documentation>
  </IntVectorProperty>
  <Hints>
    <Property name="MetaRead" show="0"/>
    <ReaderFactory extensions="bov" file_description="Brick-Of-Values files." />
  </Hints>
</SourceProxy>

<!--========================================================================-->
<SourceProxy
    name="BOVMetaReader"
    class="vtkBOVReader"
    label="BOV Meta Reader"
    base_proxyname="BOVReaderUI"
    base_proxygroup="common-ui">
  <Documentation
      short_help="BOV reader.">
      long_help="BOV Reader. Reads raw or brick of values files in parallel handles time."
  </Documentation>
  <!-- Meta Flag -->
  <IntVectorProperty 
    name="MetaRead" 
    command="SetMetaRead" 
    number_of_elements="1"
    default_values="1">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked meta mode is active. Meta data will be read and processed however actual read will be 
    deffered to down stream filters. If unchecked the reader performs as expected, an actual read of
    the requested arrays.
    </Documentation>
  </IntVectorProperty>
  <Hints>
    <Property name="MetaRead" show="0"/>
    <ReaderFactory extensions="bovm" file_description="Brick-Of-Values files." />
  </Hints>
</SourceProxy>

</ProxyGroup>


<!--
*******************************************************************************
*                                                                             *
*                                   Sources                                   *
*                                                                             *
*******************************************************************************
-->
<ProxyGroup name="common-ui">
<!-- ==================================================================== -->
  <Proxy name="SQHemisphereUI">
    
   </Proxy>
</ProxyGroup>

<ProxyGroup name="sources">

  <!-- ==================================================================== -->
  <SourceProxy name="vtkSQPlaneSource" class="vtkSQPlaneSource" label="SQ Plane">
      <Documentation
        long_help="Create a parallelogram given an origin and two points. The resolution indicates the number of division along each axis of the plane." 
        short_help="Create a parallelogram from an origin and two points">
        The Plane source can be used to add a polygonal parallelogram to the 3D scene.
      </Documentation>

      <StringVectorProperty
         name="Name"
         command="SetDescriptiveName"
         number_of_elements="1">
        <Documentation>
          Give the object a name that may be used downstream to identify it.
        </Documentation>
      </StringVectorProperty>
     <!--<StringVectorProperty name="GetName"
        command="GetDescriptiveName"
        information_only="1" >
        <SimpleStringInformationHelper />
     </StringVectorProperty>-->

      <DoubleVectorProperty
         name="Origin"
         command="SetOrigin"
         number_of_elements="3"
         animateable="1"
         default_values="0.0 0.0 0.0">
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the 3D coordinate of the origin (one corner) of the plane.
        </Documentation>
      </DoubleVectorProperty>
      <!--
      information_property="OriginInfo"
      <DoubleVectorProperty name="OriginInfo"
        command="GetOrigin"
        information_only="1"
        number_of_elements="3"
        default_values="0.0 0.0 0.0">
        <SimpleDoubleInformationHelper />
     </DoubleVectorProperty>-->

      <DoubleVectorProperty
         name="Point1"
         command="SetPoint1"
         number_of_elements="3"
         animateable="1"
         default_values="1.0 0.0 0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the 3D coordinate a second corner of the parallelogram.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="Point2"
         command="SetPoint2"
         number_of_elements="3"
         animateable="1"
         default_values="0.0 1.0 0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the 3D coordinate a third corner of the parallelogram.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="XResolution"
         command="SetXResolution"
         number_of_elements="1"
         default_values="1" >
        <IntRangeDomain name="range" min="1" />
        <Documentation>
          This property specifies the number of divisions along the X axis of the parallelogram.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="YResolution"
         command="SetYResolution"
         number_of_elements="1"
         default_values="1" >
        <IntRangeDomain name="range" min="1" />
        <Documentation>
          This property specifies the number of divisions along the Y axis of the parallelogram.
        </Documentation>
      </IntVectorProperty>
   <!-- End Plane -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy 
     name="vtkSQSphereSource"
     class="vtkSQSphereSource"
     label="SQ Sphere">
      <Documentation
        long_help="Create a 3D sphere given a center and radius."
        short_help="Create a 3D sphere">
          The Sphere source can be used to add a polygonal sphere to the 3D scene. The output of the Sphere source is polygonal data with point normals defined.
      </Documentation>

      <StringVectorProperty
         name="Name"
         command="SetDescriptiveName"
         number_of_elements="1">
        <Documentation>
          Give the object a name that may be used downstream to identify it.
        </Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty
         name="Center"
         command="SetCenter"
         number_of_elements="3"
         animateable="1"
         default_values="0.0 0.0 0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the 3D coordinates for the center of the sphere.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="Radius"
         command="SetRadius"
         number_of_elements="1"
         animateable="1"
         default_values="0.5" >
        <DoubleRangeDomain name="range" min="0"/>
        <Documentation>
          This property specifies the radius of the sphere.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="ThetaResolution"
         command="SetThetaResolution"
         number_of_elements="1"
         default_values="8" >
        <IntRangeDomain name="range" min="3" max="1024" />
        <Documentation>
          The value of this property represents the number of divisions between Start Theta and End Theta around the sphere. (See the Start Theta and End Theta properties.) The theta divisions are similar to longitude lines on the earth. The higher the resolution, the closer the approximation will come to a sphere, and the more polygons there will be.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="StartTheta"
         command="SetStartTheta"
         number_of_elements="1"
         animateable="1"
         default_values="0" >
        <DoubleRangeDomain name="range" min="0" max="360" />
        <Documentation>
          To form a complete sphere, the value of this property should be 0 degrees, and the value of the End Theta property should be 360 degrees. The value of this property can be adjusted to form only a portion of a sphere.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="EndTheta"
         command="SetEndTheta"
         number_of_elements="1"
         animateable="1"
         default_values="360" >
        <DoubleRangeDomain name="range" min="0" max="360" />
        <Documentation>
          The value of this property can be adjusted to form only a portion of a sphere. This value is measured in degrees.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="PhiResolution"
         command="SetPhiResolution"
         number_of_elements="1"
         default_values="8" >
        <IntRangeDomain name="range" min="3" max="1024" />
        <Documentation>
          The value of this property represents the number of divisions between Start Phi and End Phi on the sphere. (See the Start Phi and End Phi properties.) The phi divisions are similar to latitude lines on the earth.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="StartPhi"
         command="SetStartPhi"
         number_of_elements="1"
         animateable="1"
         default_values="0" >
        <DoubleRangeDomain name="range" min="0" max="180" />
        <Documentation>
          To form a complete sphere, the value of this property should be 0 degrees, and the value of the End Phi property should be 180 degrees. The value of this property can be adjusted to form only a portion of a sphere.
          Set the starting angle (in degrees) in the latitudinal direction.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="EndPhi"
         command="SetEndPhi"
         number_of_elements="1"
         animateable="1"
         default_values="180" >
        <DoubleRangeDomain name="range" min="0" max="180" />
        <Documentation>
          The value of this property can be adjusted to form only a portion of a sphere. The value is measured in degrees.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End Sphere -->
   </SourceProxy>

  

  <!-- ==================================================================== -->
  <SourceProxy
    name="vtkSQHemisphereSource"
    class="vtkSQHemisphereSource"
    label="SQ Hemisphere">
    <Documentation
      long_help="Create a 3D sphere given a center and radius."
      short_help="Create a 3D sphere">
      The Hemisphere source can be used to add a polygonal sphere to the 3D scene. The output of the Hemisphere source is polygonal data with point normals defined.
    </Documentation>

    <!-- Out -->
    <OutputPort name="Northern Hemisphere" index="0" />
    <OutputPort name="Southern Hemisphere" index="1" />

    <DoubleVectorProperty 
      name="GetCenter"
      command="GetCenter"
      information_only="1">
      <SimpleDoubleInformationHelper/>
    </DoubleVectorProperty>
    <DoubleVectorProperty
      name="Center"
      command="SetCenter"
      number_of_elements="3"
      animateable="1"
      default_values="0.0 0.0 0.0"
      information_property="GetCenter">
    <DoubleRangeDomain name="range"/>
    <Documentation>
      This property specifies the 3D coordinates for the center of the sphere.
    </Documentation>
  </DoubleVectorProperty>

  <DoubleVectorProperty 
    name="GetRadius"
    command="GetRadius"
    information_only="1">
    <SimpleDoubleInformationHelper/>
  </DoubleVectorProperty>
  <DoubleVectorProperty
    name="Radius"
    command="SetRadius"
    number_of_elements="1"
    animateable="1"
    default_values="0.5"
    information_property="GetRadius">
    <DoubleRangeDomain name="range" min="1E-15"/>
    <Documentation>
      This property specifies the radius of the sphere.
    </Documentation>
  </DoubleVectorProperty>

  <IntVectorProperty 
    name="GetResolution"
    command="GetResolution"
    information_only="1">
    <SimpleIntInformationHelper/>
  </IntVectorProperty>
  <IntVectorProperty
      name="Resolution"
      command="SetResolution"
      number_of_elements="1"
      default_values="8"
      information_property="GetResolution">
    <IntRangeDomain name="range" min="3" max="1024" />
    <Documentation>
      The value of this property controls the number of lat-lon linies in the output.
    </Documentation>
  </IntVectorProperty>

  <!-- End Hemisphere Source -->
  </SourceProxy>

  <!-- ==================================================================== -->
  <SourceProxy name="vtkProcessMonitor" class="vtkProcessMonitor" label="Process Monitor">
      <Documentation
        long_help="A custom Qt panel that manages and monitors the running processes."
        short_help="A custom Qt panel that manages and monitors the running processes.">
        A custom panel that manages and monitors the running processes.
      </Documentation>

     <StringVectorProperty name="ConfigStream"
        command="GetConfigStream"
        information_only="1" >
        <SimpleStringInformationHelper />
     </StringVectorProperty>

   <!-- End Debug Panel -->
   </SourceProxy>


</ProxyGroup>


<!--
*******************************************************************************
*                                                                             *
*                                   Filters                                   *
*                                                                             *
*******************************************************************************
-->
<ProxyGroup name="common-ui">
  <!-- ==================================================================== -->
  <Proxy name="vtkOOCFieldTracerUI">
    <Documentation
       long_help="Trace field lines in a vector field."
       short_help="Trace field lines in a vector field.">
      Trace field lines in a vector field.
    </Documentation>
    <!-- Dataset input -->
    <InputProperty
       name="DatasetInput"
       command="AddVectorInputConnection"
       clean_command="ClearVectorInputConnections"
       label="Vector Field">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="0">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point" number_of_components="3"/>
          <Documentation>
            Dataset containing the vector field.
          </Documentation>
     </InputProperty>
     <!-- Seed input -->
     <InputProperty
        name="SeedPointInput"
        command="AddSeedPointInputConnection"
        clean_command="ClearSeedPointInputConnections"
        label="Seed Cells"
        multiple_input="0">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <Documentation>
             Cells to generate seed points from (at cell center).
           </Documentation>
      </InputProperty>
     <!-- Terminator Surface input -->
     <InputProperty
        name="TerminatorInput"
        command="AddTerminatorInputConnection"
        clean_command="ClearTerminatorInputConnections"
        label="Terminator Surfaces"
        multiple_input="1"
        optional="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <Documentation>
             Surfaces which if present stop field line integration when a field line crosses one.
           </Documentation>
      </InputProperty>

     <!-- Vector Field Selection -->
     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="DatasetInput" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <!-- OOC Reader parameter -->
     <IntVectorProperty 
       name="OOCNeighborhoodSize" 
       label="OOC Read Size"
       command="SetOOCNeighborhoodSize"
       number_of_elements="1"
       default_values="0" >
       <IntRangeDomain name="range" min="-1"/>
       <Documentation>
         Control the size of the OOC reads (context dependent meaning).
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="InitialStep"
       label="Initial Step"
       command="SetInitialStep"
       number_of_elements="1"
       default_values="0.1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Initial integration step size as a multiple of cell lengths.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MinStep"
       label="Minimum Step"
       command="SetMinStep"
       number_of_elements="1"
       default_values="0.1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Minimum integration step size as a multiple of cell lengths.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MaxStep"
       label="Maximum Step"
       command="SetMaxStep"
       number_of_elements="1"
       default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Maximum integration step size as a multiple of cell lengths.
       </Documentation>
     </DoubleVectorProperty>  

     <IntVectorProperty 
       name="MaxNumberOfSteps"
       label="Maximum Steps"
       command="SetMaxNumberOfSteps" 
       number_of_elements="1"
       default_values="1000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         Maximum number of steps, beyond which integration is terminated.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="MaxLineLength"
       label="Maximum Length"
       command="SetMaxLineLength"
       number_of_elements="1"
       default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="10.0">
         <RequiredProperties>
            <Property name="DatasetInput" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         Maximum streamline arc length beyond which line integration is terminated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="NullThreshold"
       label="Null Threshold"
       command="SetNullThreshold"
       number_of_elements="1"
       default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the terminal speed, below which particle advection/integration is terminated.
       </Documentation>
     </DoubleVectorProperty>

      <!-- Colormap/Legened control -->
     <IntVectorProperty 
        name="Squeeze Color Map" 
        command="SetSqueezeColorMap" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
        Set the color map to simple where termination due to out of bounds,stagnation, and short integration map to the same case.
       </Documentation>
     </IntVectorProperty>

     <!-- Always use this error -->
     <DoubleVectorProperty
       name="MaxError"
       command="SetMaxError"
       number_of_elements="1"
       default_values="0.000001"/>
     <!-- Always measure integrate as multiple of cell length -->
     <IntVectorProperty 
       name="StepUnit"
       label="Step Unit"
       command="SetStepUnit" 
       number_of_elements="1"
       default_values="2"/>
     <!-- Hide some of these -->
     <Hints>
       <Visibility replace_input="2" />
       <Property name="StepUnit" show="0"/>
       <Property name="MaxError" show="0"/>
     </Hints>
   <!-- End FieldTracerUI -->
   </Proxy>

</ProxyGroup>

<ProxyGroup name="filters">

<!-- ==================================================================== -->
<SourceProxy name="vtkOOCDFieldTracer" 
    class="vtkOOCDFieldTracer"
    label="OOCD Field Tracer"
    base_proxyname="vtkOOCFieldTracerUI"
    base_proxygroup="common-ui">

  <!-- Out -->
  <OutputPort name="Field Lines" index="0" />

  <!-- Topo Flag -->
  <IntVectorProperty 
    name="Mode"
    command="SetMode"
    number_of_elements="1"
    default_values="1">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked topology mode is active and the filter produces a topology
    map rather than field lines.
    </Documentation>
  </IntVectorProperty>

  <!-- Load balancing/work scheduling control -->
  <IntVectorProperty 
    name="UseDynamicScheduler"
    command="SetUseDynamicScheduler"
    number_of_elements="1"
    default_values="0" > 
    <BooleanDomain name="bool"/>
    <Documentation>
    When set the work is by a simple self-scheduling algorithm. In this case all of the seed source data has to be duplicated 
    on all processes. This must be off if this is not the case.
    </Documentation>
  </IntVectorProperty>

  <!-- Load balancing controls -->
  <IntVectorProperty 
    name="MasterBlockSize"
    command="SetMasterBlockSize"
    number_of_elements="1"
    default_values="16"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work the master does in between servicing work requests
      from the workers. Should be much smaller the WorkerBlockSize.
    </Documentation>
  </IntVectorProperty>
    <IntVectorProperty 
    name="WorkerBlockSize"
    command="SetWorkerBlockSize"
    number_of_elements="1"
    default_values="512"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work is given to the worker processes at each
      request.
    </Documentation>
  </IntVectorProperty>

  <Hints>
    <Property name="Mode" show="0"/>
    <Property name="StepUnit" show="0"/>
    <Property name="MaxError" show="0"/>
  </Hints>
   <!-- End OOCFieldTracer -->
</SourceProxy>


<!-- ==================================================================== -->
<SourceProxy name="vtkOOCDFieldTopologyMapper" 
    class="vtkOOCDFieldTracer"
    label="OOCD Field Topology Mapper"
    base_proxyname="vtkOOCFieldTracerUI"
    base_proxygroup="common-ui">

  <!-- Out -->
  <OutputPort name="Topology Map" index="0" />

  <!-- Topo Flag -->
  <IntVectorProperty 
    name="Mode" 
    command="SetMode" 
    number_of_elements="1"
    default_values="0">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked topology mode is active and the filter produces a topology
    map rather than field lines.
    </Documentation>
  </IntVectorProperty>

  <!-- Load balancing/work scheduling control -->
  <IntVectorProperty 
    name="Use Dynamic Scheduler"
    command="SetUseDynamicScheduler"
    number_of_elements="1"
    default_values="1" > 
    <BooleanDomain name="bool"/>
    <Documentation>
    When set the work is by a simple self-scheduling algorithm. In this case all of the seed source data has to be duplicated 
    on all processes. This must be off if this is not the case.
    </Documentation>
  </IntVectorProperty>

  <!-- Load balancing controls -->
  <IntVectorProperty 
    name="MasterBlockSize"
    command="SetMasterBlockSize"
    number_of_elements="1"
    default_values="16"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work the master does in between servicing work requests
      from the workers. Should be much smaller the WorkerBlockSize.
    </Documentation>
  </IntVectorProperty>
    <IntVectorProperty 
    name="WorkerBlockSize"
    command="SetWorkerBlockSize"
    number_of_elements="1"
    default_values="512"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work is given to the worker processes at each
      request.
    </Documentation>
  </IntVectorProperty>

  <Hints>
    <Property name="Mode" show="0"/>
    <Property name="StepUnit" show="0"/>
    <Property name="MaxError" show="0"/>
  </Hints>
   <!-- End FieldTracer -->
</SourceProxy>


<!-- ==================================================================== -->
<SourceProxy name="vtkOOCDPoincareMapper"
    class="vtkOOCDFieldTracer"
    label="OOCD Poincare Mapper"
    base_proxyname="vtkOOCFieldTracerUI"
    base_proxygroup="common-ui">

  <!-- Out -->
  <OutputPort name="Field Lines" index="0" />

  <!-- Topo Flag -->
  <IntVectorProperty
    name="Mode"
    command="SetMode"
    number_of_elements="1"
    default_values="2">
    <BooleanDomain name="bool"/>
    <Documentation>
    If checked topology mode is active and the filter produces a topology
    map rather than field lines.
    </Documentation>
  </IntVectorProperty>
  
  <!-- Load balancing/work scheduling control -->
  <IntVectorProperty 
    name="Use Dynamic Scheduler"
    command="SetUseDynamicScheduler"
    number_of_elements="1"
    default_values="0" > 
    <BooleanDomain name="bool"/>
    <Documentation>
    When set the work is by a simple self-scheduling algorithm. In this case all of the seed source data has to be duplicated 
    on all processes. This must be off if this is not the case.
    </Documentation>
  </IntVectorProperty>

  <!-- Load balancing controls -->
  <IntVectorProperty 
    name="MasterBlockSize"
    command="SetMasterBlockSize"
    number_of_elements="1"
    default_values="16"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work the master does in between servicing work requests
      from the workers. Should be much smaller the WorkerBlockSize.
    </Documentation>
  </IntVectorProperty>
    <IntVectorProperty 
    name="WorkerBlockSize"
    command="SetWorkerBlockSize"
    number_of_elements="1"
    default_values="512"
    animateable="0">
    <IntRangeDomain name="range" min="1" max="131072"/>
    <Documentation>
      Controls how much work is given to the worker processes at each
      request.
    </Documentation>
  </IntVectorProperty>

  <Hints>
    <Property name="Mode" show="0"/>
    <Property name="UseDynamicScheduler" show="0"/>
    <Property name="MasterBlockSize" show="0"/>
    <Property name="WorkerBlockSize" show="0"/>
    <Property name="StepUnit" show="0"/>
    <Property name="MaxError" show="0"/>
  </Hints>
   <!-- End OOCFieldTracer -->
</SourceProxy>


  <!-- ==================================================================== -->
  <SourceProxy 
    name="vtkSQVortexFilter" 
    class="vtkSQVortexFilter"
    label="SQ Vortex Detect">
    <Documentation
      long_help="Long Documentation"
      short_help="Short Documentation">
      Textual Documentation.
    </Documentation>

     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             This property specifies the input to the Warp (vector) filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         label="Vectors">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              Identifies the vector field on which to operate.
            </Documentation>
      </StringVectorProperty> 

     <IntVectorProperty
        name="ComputeRotation"
        label="Rotation"
        command="SetComputeRotation"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Compute the rotation (curl) of the vector field using a point centered stencil.
        </Documentation>
     </IntVectorProperty>

      <IntVectorProperty
        name="ComputeHelicity"
        label="Helicity"
        command="SetComputeHelicity"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Compute the helicity (dot of vector and its curl) of the vector field using a point centered stencil.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeNormalizedHelicity"
        label="Normalized helicity"
        command="SetComputeNormalizedHelicity"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Compute the normailzed helicity of the vector field using a point centered stencil.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeLambda"
        label="Lambda-(1,2,3)"
        command="SetComputeLambda"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Compute the 3 eigenvalues of corrected pressure hessian.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeLambda2"
        label="Lambda-2"
        command="SetComputeLambda2"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Compute the second eigenvalue of corrected pressure hessian.
        </Documentation>
     </IntVectorProperty>

  <!-- End vtkSQVortexFilter -->
  </SourceProxy>

  <!-- ==================================================================== -->
  <SourceProxy 
    name="vtkRandomSeedPoints" 
    class="vtkRandomSeedPoints"
    label="Random Seed Points">
    <Documentation
      long_help="Long Documentation"
      short_help="Short Documentation">
      Textual Documentation.
    </Documentation>

     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
      </InputProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        label="Number Of Points"
        command="SetNumberOfPoints"
        number_of_elements="1"
        default_values="10">
     </IntVectorProperty>

  <!-- End vtkSQVortexFilter -->
  </SourceProxy>


  
</ProxyGroup>

</ServerManagerConfiguration>
